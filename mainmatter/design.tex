\chapter{Design}
\label{Chapter:Design}

This chapter discusses the design considerations taken during the design development of the system. The design stage is very important since it lays down the foundation for the whole system.
Thus a considerable amount of time has been spent in designing the system. \citet[12]{bell2005} states that about 5\% of the total time that takes for the development of a software should be spent for the design state alone. For comparison, the coding process takes about 7\%; Testing takes 8\%. 

The design process has gone through many iterations to ensure the best possible quality of the product. The research presented in chapter \ref{Chapter:Literature-Review} has affected immensely the design, especially section \ref{section:commercial-har-systems}. The design can be split into four main sections, namely Mobile Platform and IDE; Database Design; Architectural design and User Interface (UI).

    

    \section{Mobile Platform and IDE}
    The first point that was considered in the design process was the \textbf{mobile platform} on which the proposed application will be implemented and distributed. After research on the current market, Google's \textit{Android} was fount to dominate in Europe \citep{williams2016}. Android-based smartphones hold 75.6\% of market share dominating other mobile platforms such as Apple's \textit{iOS} and Microsoft's \textit{Windows Phone}. Thus, Android OS was chosen to form the basis of the proposed mobile application since it will allow the application to be downloaded and used by as many people as possible.
        
    After choosing the mobile platform, one important decision is to choose the development environment or the \textbf{Integrated Development Environment} (\gls{ide}) that will be used to develop the application. That was an easy decision since Android Studio is known to be the official \gls{ide} for Android development \citep{androidstudio2017}. It provides all the necessary developer tools such as \textit{Android Emulator} which is a basically a virtual phone that allows a developer to test an application on different versions of the platform. In addition, it supports direct integration of version control systems such as \textit{Git}.
    
    \section{HAR}
    The Human Activity Recognition procedure involves standard stages such as \textit{Data Preprocessing}, \textit{Feature Extraction} and \textit{Feature Selection} (see section \ref{section:feature-selection&extraction}). The block diagram of the \gls{har} process can be seen in figure \ref{fig:har_process}. Weka\footnote{\url{http://www.cs.waikato.ac.nz/ml/weka/}} Data Mining Software has been chosen for the implementation of the \gls{har} component of the proposed system. Since there is no official support of the Weka API for the Android platform, a stripped-down version\footnote{\url{https://github.com/rjmarsan/Weka-for-Android}} of the original Weka Java API has been chosen. It this library was tested prior to the design stage to ensure it is working on an android device properly. 
    
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node at (1.2,3) {Time window};
            \draw (0,0) rectangle (2.4,2);
            \draw [decorate,decoration={brace,amplitude=10pt}] (0.0,2.2) -- (2.4,2.2); 
            \draw (0,0.66) -- (2.4,0.66);
            \draw (0,1.32) -- (2.4,1.32);
            \node at (1.2,1) {Sample};
            \node at (1.2,0.3) {Sample};
            \node at (1.2,1.7) {Sample};
            \draw [->] (2.4,1) -- (3.4,1);
            \draw (3.4,0) rectangle (6.9,2);
            \node at (5.2,1) {Data Preprocessing};
            \draw [->] (6.9,1) -- (7.9,1);
            \draw (7.9,0) rectangle (11.4,2);
            \node at (9.7,1.5) {Feature Extraction};
            \node at (9.7,1) {and};
            \node at (9.7,0.5) {Feature Selection};
            \draw [->] (11.4,1) -- (12.4,1);
            \draw (12.4,0) rectangle (14.4,2);
            \node at (13.4,1) {Classifier};
        \end{tikzpicture}
        \caption{Human Activity Recognition process}
        \label{fig:har_process}
    \end{figure}
    
    \subsection{Dataset}
    As it was mentioned in section \ref{section:proposed-application}, \textit{"Active Minutes"} is using a \textit{Supervised} learning method. This learning method require a labeled \textit{"training data"} or \textit{"data set"} order to build a classifier (or model). After a classifier is build it can be used to classify \textit{"unseen"} or \textit{"unlabelled"} data.
    
    
    \subsection{Data Processing}
    The data processing stage of \gls{har} normally involves segmenting the data into time windows. Considering the fact that the system will be running on a mobile device with limited resources, the window length has to be picked carefully. For example, choosing a 20-second window length (see figure \ref{fig:har_process}) will cause the CPU to do more work due to the amount of \textit{samples} in the time window. Consequently, that would lead to a higher battery consumption \citep[2]{torreshuitzil2015a}. As it was found in the literature review (see section \ref{section:learning_alg_accuracy_power_consm}), 3-second time window produces good results in terms of power consumption. Based on those findings, the proposed application will adopt this window length as well.
    
    During this stage, different filters could be applied to the raw data to remove unwanted information. For example, according to \citet[]{googlemotionsensors}, the raw data from an accelerometer sensor contains the earth's gravity force as well. This will cause the device to read magnitude of g = 9.81 m/s2 when it is not accelerating (i.e. laying down on a table). In order to obtain just the linear acceleration without natural forces (i.e. earth's gravitation), a low-pass filter is applied.
    
    In order to reduce the effect of device location (e.g. where the device is ) the magnitude of the accelerometer's x,y and z axis is also calculated during this stage and used as a 4th axis \textit{"m"} (see equation \ref{eq:acceleration_magnitude} bellow). This technique has been used in previous works as well \citep[153]{torreshuitzil2015b}.
    
    \begin{equation}
        \label{eq:acceleration_magnitude}
        m = \sqrt{x^2 + y^2 + z^2}
    \end{equation}
    
    \subsection{Feature Extraction and Feature Selection}
    \textbf{Feature extraction} is an important process in a \gls{har} system. It allows extracting key characteristics from a raw data and used to represent important patterns with reduced dimensionality \citep[154]{torreshuitzil2015b}. During the initial research (see section \ref{section:feature-selection&extraction}) it was found that extracting the first \gls{fft} algorithm coefficients produce higher accuracy compared to the rest of the features (e.g. Time domain features such as Mean or Standard Deviation). To ease the development process, a third-party library called \textit{JTransforms} \footnote{\url{https://github.com/wendykierp/JTransforms}} has been utilised to convert the Time-Domain raw accelerometer data (data collected over a time period) into a Frequency-Domain data by applying the above-mentioned algorithm. The total number of features that are extracted from the raw accelerometer sensor is 20. That includes the first 5 \gls{fft} coefficients of the x,y and z axis as well as their magnitude. 
    
    \textbf{Feature selection} algorithms can be applied after the Feature Extraction process to reduce the number of features, and thus simplifying the classifier (see section \ref{section:feature-selection&extraction}). The main goal of the feature selection algorithm is to select a subset from the original data features that can accurately carry the original meaning of the data \citep[22]{wu2008}. For example, if the original number of features is 20 after applying a feature selection algorithm that number could be reduced to 13 which would lead to a faster CPU processing. A Correlation based Feature Selection (CFS) algorithm has been chosen for the implementation of the feature selection process since it showed good results in previous works \citep[220-224]{dinhle2015}. The \gls{cfs} algorithm selects a subset of features based on two factors. First the algorithm calculates the correlation between the feature-class and feature-feature. The feature-class correlation shows how much a feature is related to a certain class (i.e. such as \textit{"walking"} or \textit{"static"}). On the other hand, the feature-feature correlation shows how individual features relate to each other.
    
    \subsection{Classifier}
    After the Data Processing and Feature Extraction and Feature Selection stages a classifier is built. The initial research suggested the use of the k-Nearest Neighbors (kNN) algorithm to build the classifier due to the fact that it does not require much CPU work and thus it is battery friendly (see \ref{section:learning_alg_accuracy_power_consm}). Based on those findings, the proposed mobile system will employ the same learning algorithm. 
    
        
    \section{Architectural design}
    This section discusses the software software architecture of the mobile application. The architectural design is the first stage in the design process of a system. It creates a critical link between the requirements discussed in Chapter \ref{Chapter:Specification} and the research knowledge gained in Chapter \ref{Chapter:Literature-Review}. The end-goal of the architectural design is to discover the major structural components of the system and how they communicate to each other \citep[148]{sommerville2010}. The architectural model of the system can be seen in figure \ref{fig:architectural_design_component_diagram}.
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=15cm]{active-minutes-service-component-diagram}
        \caption{ \textit{"Active Minutes"} Architectural model}
        \label{fig:architectural_design_component_diagram}
    \end{figure}
    
    Model-View-Presenter or \textbf{MVP} software architectural pattern was chosen to form the base of the proposed mobile system since it provides clean separation of concepts \citep[532]{zhang2010}. For example the \textit{View} represents the \gls{ui} of the application. It contains logic for receiving user interaction and notifying the \textit{Presenter}. The \textit{Model} is the data layer. It is responsible for providing and formatting (i.e. applying the business logic) the data and returning it to the Presenter. The \textit{Presenter} acts as a mediator, it requests data from the \textit{Model} and returns it to update the \textit{View}. Figure \ref{fig:model_view_presenter_design_pattern} shows the interaction flow of the pattern. When the user interacts with the \gls{ui} of mobile application, the View receives the interaction (i.e. button click) and passes that information to the Presenter via Interface (\textit{IView}). The Presenter then invokes the appropriate method of the Model. Next, the Model returns the requested data to the View (via the Presenter). 
        
    The main \textbf{advantages} of using the \gls{mvp} pattern is that it increases the \textbf{testability} of the software via the concept of logic separation. For example, the View is only allowed to have framework specific code (i.e. Android UI components such as Button, ListView); Presenter and Model are comprised of Plain Old Java Objects or \textbf{POJO}. These POJO classes can be thoroughly tested outside the mobile application. In addition, the \gls{mvp} pattern introduces a certain level of abstraction in the software architecture (via the use of Java Interfaces, see figure \ref{fig:architectural_design_component_diagram}). That allows different parts of the software to be developed separately and then integrated into the application. The components of the system will be discussed in the following sections.
    
    \begin{figure}[ht]
        \centering
        \includegraphics[width=15cm]{model-view-presenter-design-pattern}
        \caption{Model-View-Presenter design pattern \citep[28]{syromiatnikov2014}}
        \label{fig:model_view_presenter_design_pattern}
    \end{figure}
        
        \subsection{Models}
        As it can be seen from figure \ref{fig:architectural_design_component_diagram} the \textit{Model} layer of the system architecture is comprised of \textit{DataManager}, \textit{ActiveMinutesService}, \textit{ClassifierPersonalisationService} and \textit{DataCollectionService}. These components will be discussed next.
        
            \subsubsection{DataManager}
            The \textbf{\textit{DataManager}}, as the name implies, will be responsible for providing means of accessing the underling database object. For example, returning a list of activities for the logged in user. Almost all of the diagram components have access to an instance of the DataManager component (or Java Class) so they can perform operations such as saving a new user or loading user's physical activity goal. This class essentially will be a wrapper class of a \textbf{Realm} database object. After initial research, \citet{realm2014} was chosen to form the database of the mobile application. It is a third-party Android library was found to be x100 faster compared to the Android native SQLite database systems.
            
            \subsubsection{ActiveMinutesService}
            Since \textit{"Active Minutes"} has to collect contextual information throughout the user's day continuously, \textbf{\textit{ActiveMinutesService}} is implemented as \textit{Service}. According to \citet{googleservices2017}, a Service is an Android application component that continuously runs in the background even if the user closes or switches to another application. The responsibilities of this service include \gls{har}, storing the recognised activities in the database and performs additional checks such as whether or not to send reminder notifications to the user.
            
            \subsubsection{ClassifierPersonalisationService}
            The solo purpose of this service is to personalise the general classifier that is included in the application initially. It will be started by the above mentioned \textit{ActiveMinutesService} service when enough labeled data is collected. For example, the service is executed when there are x100 instances of \textit{walking},\textit{running}, \textit{cycling} and \textit{static} activity training data. Since it will run once in the lifetime of the application on the device, this service is implemented as a special kind of Service called \textit{IntentService}. It allows for execution of heavy tasks (such as training a classifier) in a worker (i.e. background) thread so the application's main thread (or \gls{ui} thread) is not affected.
            
            \subsubsection{DataCollectionService}
            In order to train a \gls{har} classifier, a training dataset is required. This service is responsible for the data collection process. That includes reading, reprocessing and windowing the raw accelerometer data as well as abstracting the data via the means of feature extraction (see section \ref{section:feature-selection&extraction}). Each feature vector stores 20 values (the first 5 \gls{fft} coefficients of every sensor dimension, namely x,y and z and their magnitude) as a record in the \textit{Training\_data} table (see figure \ref{fig:data_modeling_er_diagram}).
    
    \section{Database Design}
    This section discuses the design of the database system that will be used to store data of \textit{"Active Minutes"} mobile application. The design of the database can be seen in figure \ref{fig:data_modeling_er_diagram}. It includes the following entities \textbf{User}, \textbf{Activity} and \textbf{Training\_data}. The following sections will explain the responsibilities of each entity (i.e.\ database tables).
        
        \begin{figure}[ht]
            \centering
            \includegraphics[width=12cm]{data-modeling-er-diagram}
            \caption{Database ER Diagram}
            \label{fig:data_modeling_er_diagram}
        \end{figure}
        
        \subsubsection{Entities}
        
        \begin{itemize}
            \item User(user\_id, password, username, pa\_goal,max\_inactivity\_time, active\_time,\newline static\_time, is\_classifier\_personalised)
            \item Training\_data(user\_id, acc\_x\_fft\_1, acc\_x\_fft\_2, acc\_x\_fft\_3, acc\_x\_fft\_4...)
            \item Activity(activity\_id, user\_id, type, date, duration)
        \end{itemize}
        
        \subsubsection{Relationships}
        \begin{itemize}
        \item Does --- User does Activity [1:m][m:o]
        \item Produces --- User produces Training\_data [1:m][m:o]
        \end{itemize}
        
        \subsection{User}
        The user table is responsible for storing the personal information of every registered user. For example, \textbf{\textit{user\_id}} (number) will allow every user to be uniquely identified so further information can be accessed. The table will also store the \textbf{\textit{username}} and \textbf{\textit{password}} of every user. These fields are used for the authenticating different users of the application upon login.
        
        The user table will store additional information such as the \gls{pa} goal (\textbf{\textit{pa\_goal}}) and the maximum inactivity interval (\textbf{\textit{max\_inactivity\_time}}) before a notification is send to remind the current logged-in user for the prolonged inactivity. In addition, the table stores \textbf{\textit{active\_time}} and \textbf{\textit{static\_time}}. These fields track the amount of activity and inactivity in minutes, respectively. Last but not least, the table will store a boolean field called \textbf{\textit{is\_classifier\_personalised}}. This field will be \textit{False} by default and only changed when the general classifier is personalised with user's data.
        
        \subsection{Activity}
        As it can be seen from figure \ref{fig:data_modeling_er_diagram}, the Activity table is responsible for storing information for the different activities. Every activity entry in this table has a unique identifier \textbf{\textit{activity\_id}} so every record is uniquely identified in the table itself. Also, this table has \textbf{\textit{user\_id}} field which allows for associating an activity record with a specific user.
        
        The \textbf{\textit{type}} field of the table is responsible for storing the different types of activities as mentioned in section \ref{subsection:monitoring-component} such as \textit{"walking"} or \textit{"static"}. Field \textbf{\textit{date}} as the name of the field suggest, will store the date when the activity was recorded in time. The last field of the activity table is \textbf{\textit{duration}}, this field stores the duration of the performed activity in seconds.
        
        An example of a table entry:\textit{"5,1,running,2017-01-24 20:16:09,3"}. Where \textit{"5"} is the id of the activity, \textit{"1"} is the id of the user who performed it, the next field is the date and \textit{"3"} is the duration of the activity \textit{running}.
        
        \subsection{Training\_data}
        The last database entity to discus is the Training\_data. The fields from the table \textbf{\textit{acc\_x\_fft\_1}},\newline\textbf{\textit{acc\_x\_fft\_2}},\textbf{\textit{acc\_x\_fft\_3}}... will be responsible for storing the extracted features from the raw accelerometer data as discussed in section \ref{section:proposed-application}. The table field \textbf{\textit{user\_id}} will be used to associate a user with a particular record in the table.
        
        One point to note, this table will be used for two purposes at different times of the development of the project. First, it will be used to store all of the project participants training data. This data will be used to build an initial, general classifier. When a classifier is already build, this table will be used to store the labeled data that will be used to build a personalised classifier for a particular user.
    
    
        
    \section{User Interface Design}
    TO BE DONE